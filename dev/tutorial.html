<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · BitBasis.jl</title><meta name="title" content="Tutorial · BitBasis.jl"/><meta property="og:title" content="Tutorial · BitBasis.jl"/><meta property="twitter:title" content="Tutorial · BitBasis.jl"/><meta name="description" content="Documentation for BitBasis.jl."/><meta property="og:description" content="Documentation for BitBasis.jl."/><meta property="twitter:description" content="Documentation for BitBasis.jl."/><meta property="og:url" content="https://quantumbfs.github.io/BitBasis.jl/dev/tutorial.html"/><meta property="twitter:url" content="https://quantumbfs.github.io/BitBasis.jl/dev/tutorial.html"/><link rel="canonical" href="https://quantumbfs.github.io/BitBasis.jl/dev/tutorial.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/indigo.css" rel="stylesheet" type="text/css"/><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="BitBasis.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">BitBasis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="tutorial.html">Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Conventions"><span>Conventions</span></a></li><li><a class="tocitem" href="#Integer-Representations"><span>Integer Representations</span></a></li><li><a class="tocitem" href="#bit_literal"><span>Bit String Literal</span></a></li><li><a class="tocitem" href="#Bit-Manipulations"><span>Bit Manipulations</span></a></li><li><a class="tocitem" href="#Number-Readouts"><span>Number Readouts</span></a></li><li><a class="tocitem" href="#Iterating-over-Bases"><span>Iterating over Bases</span></a></li><li><a class="tocitem" href="#Reordering-Basis"><span>Reordering Basis</span></a></li></ul></li><li><a class="tocitem" href="man.html">Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tutorial.html">Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial.html">Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumBFS/BitBasis.jl/blob/master/docs/src/tutorial.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Conventions"><a class="docs-heading-anchor" href="#Conventions">Conventions</a><a id="Conventions-1"></a><a class="docs-heading-anchor-permalink" href="#Conventions" title="Permalink"></a></h2><p>We use <span>$σ$</span> to represent a binary digit, its subtitle usually refers to the position of a given binary digit inside a number (bit string).</p><p>In computing, bit numbering (or sometimes bit endianness) is the convention used to identify the bit positions in a binary number or a container of such a value. The bit number starts with zero and is incremented by one for each subsequent bit position. See also <a href="https://en.wikipedia.org/wiki/Bit_numbering">Bit numbering</a>(<strong>(Bit endianness)</strong>).</p><p>There are two different representation orders of a bit string:</p><ul><li><strong>Least significant bit 0 bit  numbering</strong></li><li><strong>Most significant bit 0 bit numbering</strong></li></ul><h3 id="array_order"><a class="docs-heading-anchor" href="#array_order"><strong>LSB 0 bit numbering</strong></a><a id="array_order-1"></a><a class="docs-heading-anchor-permalink" href="#array_order" title="Permalink"></a></h3><p>This follows the order of <code>BitArray</code> or other array representation of bits, e.g</p><p>For number <code>0b011101</code> (<code>29</code>)</p><p class="math-container">\[\sigma_1=1, \sigma_2=0, \sigma_3=1, \sigma_4=1, \sigma_5=1, \sigma_6=0\]</p><p>See also <a href="https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering">LSB 0 bit numbering</a></p><h3 id="literal_order"><a class="docs-heading-anchor" href="#literal_order"><strong>MSB 0 bit numbering</strong></a><a id="literal_order-1"></a><a class="docs-heading-anchor-permalink" href="#literal_order" title="Permalink"></a></h3><p>This follows the order of binary literal <code>0bxxxx</code>, e.g</p><p>For number <code>0b011101</code> (<code>29</code>)</p><p class="math-container">\[\sigma_1=0, \sigma_2=1, \sigma_3=1, \sigma_4=1, \sigma_5=0, \sigma_6=1\]</p><p>See also <a href="https://en.wikipedia.org/wiki/Bit_numbering#MSB_0_bit_numbering">MSB 0 bit numbering</a>.</p><h2 id="Integer-Representations"><a class="docs-heading-anchor" href="#Integer-Representations">Integer Representations</a><a id="Integer-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-Representations" title="Permalink"></a></h2><p>We use an <code>Int</code> type to store bit-wise (spin) configurations, e.g. <code>0b011101</code> (<code>29</code>) represents the configuration</p><p class="math-container">\[\sigma_1=1, \sigma_2=0, \sigma_3=1, \sigma_4=1, \sigma_5=1, \sigma_6=0\]</p><p>so we annotate the configurations <span>$\vec σ$</span> with integer <span>$b$</span> by <span>$b = \sum\limits_i 2^{i-1}σ_i$</span>. <img src="assets/bitbasic.png" alt="11100"/> e.g. we can use a number <code>28</code> to represent bit configuration <code>0b11100</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bdistance(0b11100, 0b10101) == 2  # Hamming distance</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bit_length(0b11100) == 5</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>In <code>BitBasis</code>, we also provide a more readable way to define these kind of objects, which is called <a href="tutorial.html#bit_literal">the bit string literal</a>, most of the integer operations and <code>BitBasis</code> functions are overloaded for <a href="tutorial.html#bit_literal">the bit string literal</a>.</p><p>We can switch between binary and digital representations with</p><ul><li><code>bitarray(integers, nbits)</code>, transform integers to bistrings of type <code>BitArray</code>.</li><li><code>packabits(bitstring)</code>, transform bitstrings to integers.</li><li><code>baddrs(integer)</code>, get the locations of nonzero qubits.</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitarray(4, 5)</code><code class="nohighlight hljs ansi" style="display:block;">5-element BitVector:
 0
 0
 1
 0
 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitarray([4, 5, 6], 5)</code><code class="nohighlight hljs ansi" style="display:block;">5×3 BitMatrix:
 0  1  0
 0  0  1
 1  1  1
 0  0  0
 0  0  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; packbits([1, 1, 0])</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitarray([4, 5, 6], 5) |&gt; packbits;</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>A curried version of the above function is also provided. See also <a href="man.html#BitBasis.bitarray-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>bitarray</code></a>.</p><h2 id="bit_literal"><a class="docs-heading-anchor" href="#bit_literal">Bit String Literal</a><a id="bit_literal-1"></a><a class="docs-heading-anchor-permalink" href="#bit_literal" title="Permalink"></a></h2><p>bit strings are literals for bits, it provides better view on binary basis. you could use <a href="man.html#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a>, which looks like the following</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bit&quot;101&quot; * 2</code><code class="nohighlight hljs ansi" style="display:block;">1010 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; join([bit&quot;101&quot; for i in 1:10]...)</code><code class="nohighlight hljs ansi" style="display:block;">101101101101101101101101101101 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; repeat(bit&quot;101&quot;, 2)</code><code class="nohighlight hljs ansi" style="display:block;">101101 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bit&quot;1101&quot;[2]</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>to define a bit string with length. <code>bit&quot;10101&quot;</code> is equivalent to <code>0b10101</code> on both performance and functionality but it store the length of given bits statically. The bit string literal offers a more readable syntax for these kind of objects.</p><p>Besides bit literal, you can convert a string or an integer to bit literal by <a href="man.html#BitBasis.BitStr"><code>BitStr</code></a>, e.g</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BitStr{5}(0b00101)</code><code class="nohighlight hljs ansi" style="display:block;">00101 ₍₂₎</code></pre><h2 id="Bit-Manipulations"><a class="docs-heading-anchor" href="#Bit-Manipulations">Bit Manipulations</a><a id="Bit-Manipulations-1"></a><a class="docs-heading-anchor-permalink" href="#Bit-Manipulations" title="Permalink"></a></h2><h4 id="[readbit](@ref)-and-[baddrs](@ref)"><a class="docs-heading-anchor" href="#[readbit](@ref)-and-[baddrs](@ref)"><a href="man.html#BitBasis.readbit-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Integer"><code>readbit</code></a> and <a href="man.html#BitBasis.baddrs-Tuple{Integer}"><code>baddrs</code></a></a><a id="[readbit](@ref)-and-[baddrs](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[readbit](@ref)-and-[baddrs](@ref)" title="Permalink"></a></h4><p><img src="assets/11100.png" alt="11100"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; readbit(0b11100, 2, 3) == 0b10  # read the 2nd and 3rd bits as `x₃x₂`</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; baddrs(0b11100) == [3,4,5]  # locations of one bits</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="[bmask](@ref)"><a class="docs-heading-anchor" href="#[bmask](@ref)"><a href="man.html#BitBasis.bmask"><code>bmask</code></a></a><a id="[bmask](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[bmask](@ref)" title="Permalink"></a></h4><p>Masking technic provides faster binary operations, to generate a mask with specific position masked, e.g. we want to mask qubits <code>1, 3, 4</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mask = bmask(UInt8, 1,3,4)</code><code class="nohighlight hljs ansi" style="display:block;">0x0d</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BitStr{4}(mask)</code><code class="nohighlight hljs ansi" style="display:block;">1101 ₍₂₎</code></pre><h4 id="[allone](@ref)-and-[anyone](@ref)"><a class="docs-heading-anchor" href="#[allone](@ref)-and-[anyone](@ref)"><a href="man.html#BitBasis.allone-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>allone</code></a> and <a href="man.html#BitBasis.anyone-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>anyone</code></a></a><a id="[allone](@ref)-and-[anyone](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[allone](@ref)-and-[anyone](@ref)" title="Permalink"></a></h4><p>with this mask (masked positions are colored light blue), we have <img src="assets/1011_1101.png" alt="1011_1101"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; allone(0b1011, mask) == false # true if all masked positions are 1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; anyone(0b1011, mask) == true # true if any masked positions is 1</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="[ismatch](@ref)"><a class="docs-heading-anchor" href="#[ismatch](@ref)"><a href="man.html#BitBasis.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>ismatch</code></a></a><a id="[ismatch](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[ismatch](@ref)" title="Permalink"></a></h4><p><img src="assets/ismatch.png" alt="ismatch"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ismatch(0b1011, mask, 0b1001) == true  # true if masked part matches `0b1001`</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="[flip](@ref)"><a class="docs-heading-anchor" href="#[flip](@ref)"><a href="man.html#BitBasis.flip-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>flip</code></a></a><a id="[flip](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[flip](@ref)" title="Permalink"></a></h4><p><img src="assets/flip.png" alt="1011_1101"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; BitStr{4}(flip(0b1011, mask))  # flip masked positions</code><code class="nohighlight hljs ansi" style="display:block;">0110 ₍₂₎</code></pre><h4 id="[setbit](@ref)"><a class="docs-heading-anchor" href="#[setbit](@ref)"><a href="man.html#BitBasis.setbit-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>setbit</code></a></a><a id="[setbit](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[setbit](@ref)" title="Permalink"></a></h4><p><img src="assets/setbit.png" alt="setbit"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; setbit(0b1011, 0b1100) == 0b1111 # set masked positions 1</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="[swapbits](@ref)"><a class="docs-heading-anchor" href="#[swapbits](@ref)"><a href="man.html#BitBasis.swapbits-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:Integer"><code>swapbits</code></a></a><a id="[swapbits](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[swapbits](@ref)" title="Permalink"></a></h4><p><img src="assets/swapbits.png" alt="swapbits"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; swapbits(0b1011, 0b1100) == 0b0111  # swap masked positions</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="[neg](@ref)"><a class="docs-heading-anchor" href="#[neg](@ref)"><a href="man.html#BitBasis.neg-Union{Tuple{BitStr{N}}, Tuple{N}} where N"><code>neg</code></a></a><a id="[neg](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[neg](@ref)" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; neg(0b1011, 2) == 0b1000</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="[btruncate](@ref)-and-[breflect](@ref)"><a class="docs-heading-anchor" href="#[btruncate](@ref)-and-[breflect](@ref)"><a href="man.html#BitBasis.btruncate-Tuple{Integer, Any}"><code>btruncate</code></a> and <a href="man.html#BitBasis.breflect"><code>breflect</code></a></a><a id="[btruncate](@ref)-and-[breflect](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[btruncate](@ref)-and-[breflect](@ref)" title="Permalink"></a></h4><p><img src="assets/btruncate.png" alt="btruncate"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; btruncate(0b1011, 2) == 0b0011  # only the first two qubits are retained</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="[breflect](@ref)"><a class="docs-heading-anchor" href="#[breflect](@ref)"><a href="man.html#BitBasis.breflect"><code>breflect</code></a></a><a id="[breflect](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[breflect](@ref)" title="Permalink"></a></h4><p><img src="assets/breflect.png" alt="breflect"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; breflect(4, 0b1011) == 0b1101  # reflect little end and big end</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>For more detailed bitwise operations, see manual page <a href="index.html#BitBasis">BitBasis</a>.</p><h2 id="Number-Readouts"><a class="docs-heading-anchor" href="#Number-Readouts">Number Readouts</a><a id="Number-Readouts-1"></a><a class="docs-heading-anchor-permalink" href="#Number-Readouts" title="Permalink"></a></h2><p>In phase estimation and HHL algorithms, one need to read out qubits as integer or float point numbers. A register can be read out in different ways, like</p><ul><li><a href="man.html#BitBasis.bint-Tuple{BitStr}"><code>bint</code></a>, the integer itself</li><li><a href="man.html#BitBasis.bint_r-Tuple{Integer}"><code>bint_r</code></a>, the integer with bits small-big end reflected.</li><li><a href="man.html#BitBasis.bfloat-Tuple{Integer}"><code>bfloat</code></a>, the float point number <span>$0.σ₁σ₂ \cdots σ_n$</span>.</li><li><a href="man.html#BitBasis.bfloat_r-Tuple{Integer}"><code>bfloat_r</code></a>, the float point number <span>$0.σ_n \cdots σ₂σ₁$</span>.</li></ul><p><img src="assets/010101.png" alt="010101"/></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bint(0b010101)</code><code class="nohighlight hljs ansi" style="display:block;">0x15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bint_r(0b010101, nbits=6)</code><code class="nohighlight hljs ansi" style="display:block;">0x2a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bfloat(0b010101)</code><code class="nohighlight hljs ansi" style="display:block;">0.65625</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bfloat_r(0b010101, nbits=6);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Notice the functions with <code>_r</code> as postfix always require <code>nbits</code> as an additional input parameter to help reading, which is regarded as less natural way of expressing numbers.</p><h2 id="Iterating-over-Bases"><a class="docs-heading-anchor" href="#Iterating-over-Bases">Iterating over Bases</a><a id="Iterating-over-Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-over-Bases" title="Permalink"></a></h2><p>Counting from <code>0</code> is very natural way of iterating quantum registers, very pity for <code>Julia</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; itr = basis(4)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching basis(::Int64)

Closest candidates are:
  basis(<span class="sgr91">::AbstractArray</span>)
<span class="sgr90">   @</span> <span class="sgr35">BitBasis</span> <span class="sgr90">~/work/BitBasis.jl/BitBasis.jl/src/<span class="sgr4">bit_operations.jl:28</span></span>
  basis(<span class="sgr91">::Type{DitStr{D, N, T}}</span>) where {D, N, T}
<span class="sgr90">   @</span> <span class="sgr35">BitBasis</span> <span class="sgr90">~/work/BitBasis.jl/BitBasis.jl/src/<span class="sgr4">DitStr.jl:193</span></span>
  basis(<span class="sgr91">::DitStr</span>)
<span class="sgr90">   @</span> <span class="sgr35">BitBasis</span> <span class="sgr90">~/work/BitBasis.jl/BitBasis.jl/src/<span class="sgr4">DitStr.jl:192</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(itr)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `itr` not defined</code></pre><p><a href="man.html#BitBasis.itercontrol-Tuple{Int64, AbstractVector, Any}"><code>itercontrol</code></a> is a complicated API, but it plays an fundamental role in high performance quantum simulation of <code>Yao</code>. It is used for iterating over basis in controlled way, its interface looks like</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for each in itercontrol(7, [1, 3, 4, 7], (1, 0, 1, 0))
           println(string(each, base=2, pad=7))
       end</code><code class="nohighlight hljs ansi" style="display:block;">0001001
0001011
0011001
0011011
0101001
0101011
0111001
0111011</code></pre><h2 id="Reordering-Basis"><a class="docs-heading-anchor" href="#Reordering-Basis">Reordering Basis</a><a id="Reordering-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Reordering-Basis" title="Permalink"></a></h2><p>We store the wave function as <span>$v[b+1] := \langle b|\psi\rangle$</span>. We are able to reorder the basis as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = onehot(5, 0b11100)  # the one hot vector representation of given bits</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching onehot(::Int64, ::UInt8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reorder(v, (3,2,1,5,4)) ≈ onehot(5, 0b11001)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `v` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; invorder(v) ≈ onehot(5, 0b00111)  # breflect for each basis</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `v` not defined</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="man.html">Manual »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 20 February 2024 17:25">Tuesday 20 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
