<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · BitBasis.jl</title><link rel="canonical" href="https://quantumbfs.github.io/BitBasis.jl/latest/tutorial/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><h1>BitBasis.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Table-of-Contents-1">Table of Contents</a></li><li><a class="toctext" href="#Representations-1">Representations</a></li><li><a class="toctext" href="#Bit-Manipulations-1">Bit Manipulations</a></li><li><a class="toctext" href="#Number-Readouts-1">Number Readouts</a></li><li><a class="toctext" href="#Iterating-over-Bases-1">Iterating over Bases</a></li><li><a class="toctext" href="#Reordering-Basis-1">Reordering Basis</a></li><li><a class="toctext" href="#Bit-String-Representation-1">Bit String Representation</a></li></ul></li><li><a class="toctext" href="../man/">Manual</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/BitBasis.jl/blob/master/docs/src/tutorial.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Basics-Bitwise-Operations-1" href="#Basics-Bitwise-Operations-1">Basics Bitwise Operations</a></h1><div><pre><code class="language-julia">using BitBasis</code></pre></div><h2><a class="nav-anchor" id="Table-of-Contents-1" href="#Table-of-Contents-1">Table of Contents</a></h2><ul><li>Representations</li><li>Bit Manipulations</li><li>Number Readouts</li><li>Iterating over Bases</li><li>Reordering Basis</li><li>Bit String Representation</li></ul><h2><a class="nav-anchor" id="Representations-1" href="#Representations-1">Representations</a></h2><p>We use an <code>Int</code> type to store spin configurations, e.g. <code>0b011101</code> (<code>29</code>) represents qubit configuration</p><div>\[\sigma_1=1, \sigma_2=0, \sigma_3=1, \sigma_4=1, \sigma_5=1, \sigma_6=0\]</div><p>so we relate the configurations <span>$\vec σ$</span> with integer <span>$b$</span> by <span>$b = \sum\limits_i 2^{i-1}σ_i$</span>. <img src="../assets/bitbasic.png" alt="11100"/> e.g. we can use a digit <code>28</code> to represent bit configuration <code>0b11100</code></p><div><pre><code class="language-julia">@assert bdistance(0b11100, 0b10101) == 2  # Hamming distance
@assert bit_length(0b11100) == 5</code></pre></div><p>We can switch between binary and digital representations with</p><ul><li><code>integer(s) |&gt; bitarray(nbits)</code>, transform integers to bistrings of type <code>BitArray</code>.</li><li><code>bitstring |&gt; packabits</code>, transform bitstrings to integers.</li><li><code>integer |&gt; baddrs</code>, get the locations of nonzero qubits.</li></ul><div><pre><code class="language-julia">@show 4 |&gt; bitarray(5)
@show [4, 5, 6] |&gt; bitarray(5)
@show [1, 1 , 0] |&gt; packbits
@show [4, 5, 6] |&gt; bitarray(5) |&gt; packbits;</code></pre><pre><code class="language-none">4 |&gt; bitarray(5) = Bool[false, false, true, false, false]
[4, 5, 6] |&gt; bitarray(5) = Bool[false true false; false false true; true true true; false false false; false false false]
[1, 1, 0] |&gt; packbits = 3
([4, 5, 6] |&gt; bitarray(5)) |&gt; packbits = [4, 5, 6]
3-element view(::Array{Int64,2}, 1, :) with eltype Int64:
 4
 5
 6</code></pre></div><h2><a class="nav-anchor" id="Bit-Manipulations-1" href="#Bit-Manipulations-1">Bit Manipulations</a></h2><h4><a class="nav-anchor" id="[readbit](@ref)-and-[baddrs](@ref)-1" href="#[readbit](@ref)-and-[baddrs](@ref)-1"><a href="../man/#BitBasis.readbit-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer"><code>readbit</code></a> and <a href="../man/#BitBasis.baddrs-Tuple{Integer}"><code>baddrs</code></a></a></h4><p><img src="../assets/11100.png" alt="11100"/></p><div><pre><code class="language-julia">@assert readbit(0b11100, 2, 3) == 0b10  # read the 2nd and 3rd bits as `x₃x₂`
@assert baddrs(0b11100) == [3,4,5]  # locations of one bits</code></pre></div><h4><a class="nav-anchor" id="[bmask](@ref)-1" href="#[bmask](@ref)-1"><a href="../man/#BitBasis.bmask"><code>bmask</code></a></a></h4><p>Masking technic provides faster binary operations, to generate a mask with specific position masked, e.g. we want to mask qubits <code>1, 3, 4</code></p><div><pre><code class="language-julia">mask = bmask(UInt8, 1,3,4)
@assert mask == 0b1101;</code></pre></div><h4><a class="nav-anchor" id="[allone](@ref)-and-[anyone](@ref)-1" href="#[allone](@ref)-and-[anyone](@ref)-1"><a href="../man/#BitBasis.allone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>allone</code></a> and <a href="../man/#BitBasis.anyone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>anyone</code></a></a></h4><p>with this mask (masked positions are colored light blue), we have <img src="../assets/1011_1101.png" alt="1011_1101"/></p><div><pre><code class="language-julia">@assert allone(0b1011, mask) == false # true if all masked positions are 1
@assert anyone(0b1011, mask) == true # true if any masked positions is 1</code></pre></div><h4><a class="nav-anchor" id="[ismatch](@ref)-1" href="#[ismatch](@ref)-1"><a href="../man/#BitBasis.ismatch-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>ismatch</code></a></a></h4><p><img src="../assets/ismatch.png" alt="ismatch"/></p><div><pre><code class="language-julia">@assert ismatch(0b1011, mask, 0b1001) == true  # true if masked part matches `0b1001`</code></pre></div><h4><a class="nav-anchor" id="[flip](@ref)-1" href="#[flip](@ref)-1"><a href="../man/#BitBasis.flip-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>flip</code></a></a></h4><p><img src="../assets/flip.png" alt="1011_1101"/></p><div><pre><code class="language-julia">@assert flip(0b1011, mask) == 0b0110  # flip masked positions</code></pre></div><h4><a class="nav-anchor" id="[setbit](@ref)-1" href="#[setbit](@ref)-1"><a href="../man/#BitBasis.setbit-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>setbit</code></a></a></h4><p><img src="../assets/setbit.png" alt="setbit"/></p><div><pre><code class="language-julia">@assert setbit(0b1011, 0b1100) == 0b1111 # set masked positions 1</code></pre></div><h4><a class="nav-anchor" id="[swapbits](@ref)-1" href="#[swapbits](@ref)-1"><a href="../man/#BitBasis.swapbits-Union{Tuple{T}, Tuple{T,Int64,Int64}} where T&lt;:Integer"><code>swapbits</code></a></a></h4><p><img src="../assets/swapbits.png" alt="swapbits"/></p><div><pre><code class="language-julia">@assert swapbits(0b1011, 0b1100) == 0b0111  # swap masked positions</code></pre></div><h4><a class="nav-anchor" id="[neg](@ref)-1" href="#[neg](@ref)-1"><a href="../man/#BitBasis.neg-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer"><code>neg</code></a></a></h4><div><pre><code class="language-julia">@assert neg(0b1011, 2) == 0b1000  # flip masked positions</code></pre></div><h4><a class="nav-anchor" id="[btruncate](@ref)-and-[breflect](@ref)-1" href="#[btruncate](@ref)-and-[breflect](@ref)-1"><a href="../man/#BitBasis.btruncate-Tuple{Integer,Any}"><code>btruncate</code></a> and <a href="../man/#BitBasis.breflect"><code>breflect</code></a></a></h4><p><img src="../assets/btruncate.png" alt="btruncate"/></p><div><pre><code class="language-julia">@assert btruncate(0b1011, 2) == 0b0011  # only the first two qubits are retained</code></pre></div><h4><a class="nav-anchor" id="[breflect](@ref)-1" href="#[breflect](@ref)-1"><a href="../man/#BitBasis.breflect"><code>breflect</code></a></a></h4><p><img src="../assets/breflect.png" alt="breflect"/></p><div><pre><code class="language-julia">@assert breflect(4, 0b1011) == 0b1101  # reflect little end and big end</code></pre></div><p>For more interesting bitwise operations, see manual page <a href="../#BitBasis-1">BitBasis</a>.</p><h2><a class="nav-anchor" id="Number-Readouts-1" href="#Number-Readouts-1">Number Readouts</a></h2><p>In phase estimation and HHL algorithms, one need to read out qubits as integer or float point numbers. A register can be read out in different ways, like</p><ul><li>bint, the integer itself</li><li>bint_r, the integer with bits small-big end reflected.</li><li>bfloat, the float point number 0.σ₁σ₂...σₙ.</li><li>bfloat_r, the float point number 0.σₙ...σ₂σ₁.</li></ul><p><img src="../assets/010101.png" alt="010101"/></p><div><pre><code class="language-julia">@show bint(0b010101)
@show bint_r(0b010101, nbits=6)
@show bfloat(0b010101)
@show bfloat_r(0b010101, nbits=6);</code></pre><pre><code class="language-none">bint(0x15) = 0x15
bint_r(0x15, nbits=6) = 0x2a
bfloat(0x15) = 0.65625
bfloat_r(0x15, nbits=6) = 0.328125
0.328125</code></pre></div><p>Notice here functions with <code>_r</code> ending always require <code>nbits</code> as an additional input parameter to help reading, which is regarded as less natural way of expressing numbers.</p><h2><a class="nav-anchor" id="Iterating-over-Bases-1" href="#Iterating-over-Bases-1">Iterating over Bases</a></h2><p>Counting from <code>0</code> is very natural way of iterating quantum registers, very pity for <code>Julia</code></p><div><pre><code class="language-julia">basis(4)</code></pre><pre><code class="language-none">0:15</code></pre></div><p><code>itercontrol</code> is a complicated API, but it plays an fundamental role in high performance quantum simulation of <code>Yao</code>. It is used for iterating over basis in controlled way, its interface looks like</p><div><pre><code class="language-julia">@doc itercontrol</code></pre><div class="markdown"><pre><code>itercontrol&#40;&#91;T&#61;Int&#93;, nbits, positions, bit_configs&#41;</code></pre>
<p>Returns an iterator which iterate through controlled subspace of bits.</p>
<h1>Example</h1>
<p>To iterate through all the bits satisfy <code>0xx10x1</code> where <code>x</code> means an arbitrary bit.</p>
<pre><code class="language-jldoctest">julia&gt; for each in itercontrol&#40;7, &#91;1, 3, 4, 7&#93;, &#40;1, 0, 1, 0&#41;&#41;
           println&#40;string&#40;each, base&#61;2, pad&#61;7&#41;&#41;
       end
0001001
0001011
0011001
0011011
0101001
0101011
0111001
0111011
</code></pre>


</div></div><h2><a class="nav-anchor" id="Reordering-Basis-1" href="#Reordering-Basis-1">Reordering Basis</a></h2><p>We store the wave function as <span>$v[b+1] := \langle b|\psi\rangle$</span>. We are able to reorder the basis as</p><div><pre><code class="language-julia">v = onehot(5, 0b11100)  # the product state
@assert reorder(v, (3,2,1,5,4)) ≈ onehot(5, 0b11001)
@assert invorder(v) ≈ onehot(5, 0b00111)  # breflect for each basis</code></pre></div><h2><a class="nav-anchor" id="Bit-String-Representation-1" href="#Bit-String-Representation-1">Bit String Representation</a></h2><p>[to be continue ...]</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../man/"><span class="direction">Next</span><span class="title">Manual</span></a></footer></article></body></html>
