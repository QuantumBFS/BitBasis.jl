var documenterSearchIndex = {"docs":
[{"location":"man.html","page":"Manual","title":"Manual","text":"CurrentModule = BitBasis\nDocTestSetup = quote\n    using BitBasis\nend","category":"page"},{"location":"man.html#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"man.html","page":"Manual","title":"Manual","text":"Modules = [BitBasis]\nOrder   = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man.html#BitBasis.BitStr","page":"Manual","title":"BitBasis.BitStr","text":"BitStr{N,T} <: Integer\n\nThe struct for bit string with fixed length N and storage type T. It is an alias of DitStr{2,N,T}.\n\nBitStr{N,T}(integer)\nBitStr64{N}(integer)\nBitStr64(vector)\nLongBitStr{N}(integer)\nLongBitStr(vector)\n\nReturns a BitStr. When the input is an integer, the bits are read from right to left. When the input is a vector, the bits are read from left to right.\n\nExamples\n\nBitStr supports some basic arithmetic operations. It acts like an integer, but supports some frequently used methods for binary basis.\n\njulia> bit\"0101\" * 2\n1010 ₍₂₎\n\njulia> join([bit\"101\" for i in 1:10])\n\"101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎\"\n\njulia> repeat(bit\"101\", 2)\n101101 ₍₂₎\n\njulia> bit\"1101\"[2]\n0\n\n\n\n\n\n","category":"type"},{"location":"man.html#BitBasis.DitStr","page":"Manual","title":"BitBasis.DitStr","text":"DitStr{D,N,T<:Integer} <: Integer\n\nThe struct for dit string with fixed length N and storage type T, where dit is a extension of dit from binary system to a d-ary system.\n\nDitStr{D,N,T}(integer)\nDitStr{D,N}(integer)\nDitStr{D}(vector)\n\nReturns a DitStr. When the input is an integer, the dits are read from right to left. When the input is a vector, the dits are read from left to right.\n\nExamples\n\njulia> DitStr{3}([1,2,1,1,0])\n01121 ₍₃₎\n\njulia> DitStr{3, 5}(71)\n02122 ₍₃₎\n\n\n\n\n\n","category":"type"},{"location":"man.html#BitBasis.DitStr-Union{Tuple{SubDitStr{D, N, T}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}","page":"Manual","title":"BitBasis.DitStr","text":"DitStr(dit::SubDitStr{D,N,T}) -> DitStr{D,N,T}\n\nRaise type SubDitStr to DitStr.\n\njulia> x = DitStr{3, 5}(71)\n02122 ₍₃₎\n\njulia> sx =  SubDitStr(x, 2, 4)\nSubDitStr{3, 5, Int64}(02122 ₍₃₎, 1, 3)\n\njulia> DitStr(sx)\n212 ₍₃₎\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.IterControl","page":"Manual","title":"BitBasis.IterControl","text":"IterControl{S}\nIterControl(n::Int, base::Int, masks, factors) -> IterControl\n\nIterator to iterate through controlled subspace. See also itercontrol.  S is the number of chunks,  n is the size of Hilbert space,  base is the base of counter,  masks and factors are helpers for enumerating over the target Hilbert Space.\n\n\n\n\n\n","category":"type"},{"location":"man.html#BitBasis.LongLongUInt","page":"Manual","title":"BitBasis.LongLongUInt","text":"LongLongUInt{C} <: Integer\n\nA LongLongUInt{C} is an integer with C UInt numbers to store the value.\n\n\n\n\n\n","category":"type"},{"location":"man.html#BitBasis.ReorderedBasis","page":"Manual","title":"BitBasis.ReorderedBasis","text":"ReorderedBasis{N, T}\n\nLazy reorderd basis.\n\n\n\n\n\n","category":"type"},{"location":"man.html#BitBasis.ReorderedBasis-Union{Tuple{Tuple{T, Vararg{T, N}}}, Tuple{T}, Tuple{N}} where {N, T<:Integer}","page":"Manual","title":"BitBasis.ReorderedBasis","text":"ReorderedBasis(orders::NTuple{N, <:Integer})\n\nReturns a lazy set of reordered basis.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.SubDitStr","page":"Manual","title":"BitBasis.SubDitStr","text":"SubDitStr{D,N,T<:Integer} <: Integer\n\nThe struct as a SubString-like object for DitStr(SubString is an official implementation of sliced strings, see String for reference). This slicing returns a view into the parent DitStr instead of making a copy (similar to the @views macro for strings).\n\nSubDitStr can be used to describe the qubit configuration within the subspace of the entire Hilbert space.It provides similar getindex, length functions as DitStr. \n\nSubDitStr(dit::DitStr{D,N,T}, i::Int, j::Int)\nSubDitStr(dit::DitStr{D,N,T}, r::AbstractUnitRange{<:Integer})\n\nOr by @views macro for DitStr (this macro makes your life easier by supporting begin and end syntax):\n\n@views dit[i:j]\n\nReturns a SubDitStr.\n\nExamples\n\njulia> x = DitStr{3, 5}(71)\n02122 ₍₃₎\n\njulia> sx =  SubDitStr(x, 2, 4) \nSubDitStr{3, 5, Int64}(02122 ₍₃₎, 1, 3)\n\njulia> @views x[2:end] \nSubDitStr{3, 5, Int64}(02122 ₍₃₎, 1, 4)\n\njulia> sx == dit\"212;3\"\ntrue\n\n\n\n\n\n","category":"type"},{"location":"man.html#BitBasis.@bit_str-Tuple{Any}","page":"Manual","title":"BitBasis.@bit_str","text":"@bit_str -> BitStr64\n\nConstruct a bit string. such as bit\"0000\". The bit strings also supports string join. Just use it like normal strings.\n\nExample\n\njulia> bit\"10001\"\n10001 ₍₂₎\n\njulia> bit\"100_111_101\"\n100111101 ₍₂₎\n\njulia> join(bit\"1001\", bit\"11\", bit\"1110\")\n1001111110 ₍₂₎\n\njulia> onehot(bit\"1001\")\n16-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n\n","category":"macro"},{"location":"man.html#BitBasis.@dit_str-Tuple{Any}","page":"Manual","title":"BitBasis.@dit_str","text":"@dit_str -> DitStr64\n\nConstruct a dit string. such as dit\"0201;3\". The dit strings also supports string join. Just use it like normal strings.\n\nExample\n\njulia> dit\"10201;3\"\n10201 ₍₃₎\n\njulia> dit\"100_121_121;3\"\n100121121 ₍₃₎\n\njulia> join(dit\"1021;3\", dit\"11;3\", dit\"1210;3\")\n1021111210 ₍₃₎\n\njulia> onehot(dit\"1021;3\")\n81-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n     ⋮\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n\n","category":"macro"},{"location":"man.html#BitBasis.@lbit_str-Tuple{Any}","page":"Manual","title":"BitBasis.@lbit_str","text":"@lbit_str -> LongBitStr\n\nLong bit string version of @bit_str macro.\n\n\n\n\n\n","category":"macro"},{"location":"man.html#BitBasis.@ldit_str-Tuple{Any}","page":"Manual","title":"BitBasis.@ldit_str","text":"@ldit_str -> LongDitStr\n\nLong dit string version of @dit_str macro.\n\n\n\n\n\n","category":"macro"},{"location":"man.html#Base.:==-Union{Tuple{N2}, Tuple{N1}, Tuple{D}, Tuple{SubDitStr{D, N1}, DitStr{D, N2}}} where {D, N1, N2}","page":"Manual","title":"Base.:==","text":"==(lhs::SubDitStr{D,N,T}, rhs::DitStr{D,N,T}) -> Bool\n==(lhs::DitStr{D,N,T}, rhs::SubDitStr{D,N,T}) -> Bool\n==(lhs::SubDitStr{D,N,T}, rhs::SubDitStr{D,N,T}) -> Bool\n\nCompare the equality between SubDitStr and DitStr. \n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.allone-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Manual","title":"BitBasis.allone","text":"allone(index::Integer, mask::Integer) -> Bool\n\nReturn true if all masked position of index is 1.\n\nExample\n\ntrue if all masked positions are 1.\n\njulia> allone(0b1011, 0b1011)\ntrue\n\njulia> allone(0b1011, 0b1001)\ntrue\n\njulia> allone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.anyone-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Manual","title":"BitBasis.anyone","text":"anyone(index::Integer, mask::Integer) -> Bool\n\nReturn true if any masked position of index is 1.\n\nExample\n\ntrue if any masked positions is 1.\n\njulia> anyone(0b1011, 0b1001)\ntrue\n\njulia> anyone(0b1011, 0b1100)\ntrue\n\njulia> anyone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.baddrs-Tuple{Integer}","page":"Manual","title":"BitBasis.baddrs","text":"baddrs(b::Integer) -> Vector\n\nget the locations of nonzeros bits, i.e. the inverse operation of bmask.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.basis-Tuple{DitStr}","page":"Manual","title":"BitBasis.basis","text":"basis(ditstr) -> UnitRange{DitStr{D,N,T}}\nbasis(DitStr{D,N,T}) -> UnitRange{DitStr{D,N,T}}\n\nReturns the UnitRange for basis in Hilbert Space of qudits.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bdistance-Union{Tuple{Ti}, Tuple{Ti, Ti}} where Ti<:Integer","page":"Manual","title":"BitBasis.bdistance","text":"bdistance(i::Integer, j::Integer) -> Int\n\nReturn number of different bits.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bfloat-Tuple{Integer}","page":"Manual","title":"BitBasis.bfloat","text":"bfloat(b::Integer; nbits::Int=bit_length(b)) -> Float64\n\nfloat view, with current bit numbering. See also bfloat_r.\n\nRef: wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bfloat-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"Manual","title":"BitBasis.bfloat","text":"bfloat(b::BitStr) -> Float64\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bfloat_r-Tuple{Integer}","page":"Manual","title":"BitBasis.bfloat_r","text":"bfloat_r(b::Integer; nbits::Int=bit_length(b)) -> Float64\n\nfloat view, with reversed bit numbering. See also bfloat.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bfloat_r-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"Manual","title":"BitBasis.bfloat_r","text":"bfloat_r(b::BitStr) -> Float64\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bint-Tuple{BitStr}","page":"Manual","title":"BitBasis.bint","text":"bint(b::BitStr) -> Integer\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bint-Tuple{Integer}","page":"Manual","title":"BitBasis.bint","text":"bint(b; nbits=nothing) -> Int\n\ninteger view, with LSB 0 bit numbering. See also wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bint_r-Tuple{Integer}","page":"Manual","title":"BitBasis.bint_r","text":"bint_r(b; nbits::Int) -> Integer\n\ninteger read in inverse order.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bint_r-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"Manual","title":"BitBasis.bint_r","text":"bint_r(b::BitStr) -> Integer\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bit_length-Tuple{Integer}","page":"Manual","title":"BitBasis.bit_length","text":"bit_length(x::Integer) -> Int\n\nReturn the number of bits required to represent input integer x.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bitarray-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:Number","page":"Manual","title":"BitBasis.bitarray","text":"bitarray(v::Vector, [nbits::Int]) -> BitArray\nbitarray(v::Int, nbits::Int) -> BitArray\nbitarray(nbits::Int) -> Function\n\nConstruct BitArray from an integer vector, if nbits not supplied, it is 64. If an integer is supplied, it returns a function mapping a Vector/Int to bitarray.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bmask","page":"Manual","title":"BitBasis.bmask","text":"bmask(::Type{T}) where T <: Integer -> zero(T)\nbmask([T::Type], positions::Int...) -> T\nbmask([T::Type], range::UnitRange{Int}) -> T\n\nReturn an integer mask of type T where 1 is the position masked according to positions or range. Directly use T will return an empty mask 0.\n\n\n\n\n\n","category":"function"},{"location":"man.html#BitBasis.breflect","page":"Manual","title":"BitBasis.breflect","text":"breflect(b::Integer[, masks::Vector{Integer}]; nbits) -> Integer\n\nReturn left-right reflected integer.\n\nExample\n\nReflect the order of bits.\n\njulia> breflect(0b1011; nbits=4) == 0b1101\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man.html#BitBasis.breflect-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"Manual","title":"BitBasis.breflect","text":"breflect(bit_str[, masks])\n\nReturn left-right reflected bit string.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.bsizeof-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Manual","title":"BitBasis.bsizeof","text":"bsizeof(::Type)\n\nReturns the size of given type in number of binary digits.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.btruncate-Union{Tuple{T}, Tuple{T, Any}} where T<:Integer","page":"Manual","title":"BitBasis.btruncate","text":"btruncate(b, n)\n\nTruncate bits b to given length n.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.controldo-Union{Tuple{S}, Tuple{Union{Function, Type}, IterControl{S}}} where S","page":"Manual","title":"BitBasis.controldo","text":"controldo(f, itr::IterControl)\n\nExecute f while iterating itr.\n\nnote: Note\nthis is faster but equivalent than using itr as an iterator. See also itercontrol.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.controller-Tuple{Union{UnitRange{T}, Tuple{Vararg{T, var\"#s14\"}} where var\"#s14\", Vector{T}, T} where T<:Integer, Union{UnitRange{T}, Tuple{Vararg{T, var\"#s14\"}} where var\"#s14\", Vector{T}, T} where T<:Integer}","page":"Manual","title":"BitBasis.controller","text":"controller([T=Int, ]cbits, cvals) -> Function\n\nReturn a function that checks whether a basis at cbits takes specific value cvals.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.flip-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Manual","title":"BitBasis.flip","text":"flip(index::Integer, mask::Integer) -> Integer\n\nReturn an Integer with bits at masked position flipped.\n\nExample\n\njulia> flip(0b1011, 0b1011) |> BitStr{4}\n0000 ₍₂₎\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.group_shift!-Tuple{Int64, AbstractVector{Int64}}","page":"Manual","title":"BitBasis.group_shift!","text":"group_shift!(nbits, positions)\n\nShift bits on positions together.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.hypercubic-Tuple{Array}","page":"Manual","title":"BitBasis.hypercubic","text":"hypercubic(A::Array) -> Array\n\nget the hypercubic representation for an array.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.indicator-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:Integer","page":"Manual","title":"BitBasis.indicator","text":"indicator(::Type{T}, k) -> T\n\nReturn an integer with k-th bit set to 1.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.indices_with-Tuple{Int64, Vector{Int64}, Vector{Int64}}","page":"Manual","title":"BitBasis.indices_with","text":"indices_with(n::Int, locs::Vector{Int}, vals::Vector{Int}) -> Vector{Int}\n\nReturn indices with specific positions locs with value vals in a hilbert space of n qubits.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.invorder-Tuple{AbstractVecOrMat}","page":"Manual","title":"BitBasis.invorder","text":"invorder(X::AbstractVecOrMat)\n\nInverse the order of given vector/matrix X.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T<:Integer","page":"Manual","title":"BitBasis.ismatch","text":"ismatch(index::Integer, mask::Integer, target::Integer) -> Bool\n\nReturn true if bits at positions masked by mask equal to 1 are equal to target.\n\nExample\n\njulia> n = 0b11001; mask = 0b10100; target = 0b10000;\n\njulia> ismatch(n, mask, target)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.itercontrol-Tuple{Int64, AbstractVector, Any}","page":"Manual","title":"BitBasis.itercontrol","text":"itercontrol([T=Int], nbits, positions, bit_configs)\n\nReturns an iterator which iterate through controlled subspace of bits.\n\nExample\n\nTo iterate through all the bits satisfy 0xx10x1 where x means an arbitrary bit.\n\njulia> for each in itercontrol(7, [1, 3, 4, 7], (1, 0, 1, 0))\n           println(string(each, base=2, pad=7))\n       end\n0001001\n0001011\n0011001\n0011011\n0101001\n0101011\n0111001\n0111011\n\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.log2dim1-Tuple{Any}","page":"Manual","title":"BitBasis.log2dim1","text":"log2dim1(X)\n\nReturns the log2 of the first dimension's size.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.log2i","page":"Manual","title":"BitBasis.log2i","text":"log2i(x::Integer) -> Integer\n\nReturn log2(x), this integer version of log2 is fast but only valid for number equal to 2^n.\n\n\n\n\n\n","category":"function"},{"location":"man.html#BitBasis.neg-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"Manual","title":"BitBasis.neg","text":"neg(b::BitStr) -> BitStr\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.neg-Union{Tuple{T}, Tuple{T, Int64}} where T<:Integer","page":"Manual","title":"BitBasis.neg","text":"neg(index::Integer, nbits::Int) -> Integer\n\nReturn an integer with all bits flipped (with total number of bit nbits).\n\nExample\n\njulia> neg(0b1111, 4) |> BitStr{4}\n0000 ₍₂₎\n\njulia> neg(0b0111, 4) |> BitStr{4}\n1000 ₍₂₎\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.next_reordered_basis-Union{Tuple{T}, Tuple{N}, Tuple{T, Tuple{Vararg{T, N}}, Tuple{Vararg{T, N}}}} where {N, T}","page":"Manual","title":"BitBasis.next_reordered_basis","text":"next_reordered_basis(basis, takers, differ)\n\nReturns the next reordered basis accroding to current basis.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.onehot-Union{Tuple{T1}, Tuple{N}, Tuple{T}, Tuple{D}, Tuple{Type{T}, DitStr{D, N, T1}}} where {D, T, N, T1}","page":"Manual","title":"BitBasis.onehot","text":"onehot([T=Float64], dit_str[; nbatch])\n\nCreate an onehot vector in type Vector{T} or a batch of onehot vector in type Matrix{T}, where index x + 1 is one. One can specify the value of the nonzero entry by inputing a pair.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.packbits-Tuple{AbstractVector}","page":"Manual","title":"BitBasis.packbits","text":"packbits(arr::AbstractArray) -> AbstractArray\n\npack bits to integers, usually take a BitArray as input.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.readat-Union{Tuple{T}, Tuple{N}, Tuple{D}, Tuple{DitStr{D, N, T}, Vararg{Integer}}} where {D, N, T}","page":"Manual","title":"BitBasis.readat","text":"readat(x, loc...) -> Integer\n\nRead the dit config at given location.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.readbit-Union{Tuple{T}, Tuple{T, Int64}} where T<:Integer","page":"Manual","title":"BitBasis.readbit","text":"readbit(x, loc...)\n\nRead the bit config at given location.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.reorder","page":"Manual","title":"BitBasis.reorder","text":"reorder(X::AbstractArray, orders)\n\nReorder X according to orders.\n\ntip: Tip\nAlthough orders can be any iterable, Tuple is preferred inorder to gain as much performance as possible. But the conversion won't take much anyway.\n\n\n\n\n\n","category":"function"},{"location":"man.html#BitBasis.setbit-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Manual","title":"BitBasis.setbit","text":"setbit(index::Integer, mask::Integer) -> Integer\n\nset the bit at masked position to 1.\n\nExample\n\njulia> setbit(0b1011, 0b1100) |> BitStr{4}\n1111 ₍₂₎\n\njulia> setbit(0b1011, 0b0100) |> BitStr{4}\n1111 ₍₂₎\n\njulia> setbit(0b1011, 0b0000) |> BitStr{4}\n1011 ₍₂₎\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.swapbits-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:Integer","page":"Manual","title":"BitBasis.swapbits","text":"swapbits(n::Integer, mask_ij::Integer) -> Integer\nswapbits(n::Integer, i::Int, j::Int) -> Integer\n\nReturn an integer with bits at i and j flipped.\n\nExample\n\njulia> swapbits(0b1011, 0b1100) == 0b0111\ntrue\n\ntip: Tip\nlocations i and j specified by mask could be faster when bmask is not straight forward but known by constant.\n\nwarning: Warning\nmask_ij should only contain two 1, swapbits will not check it, use at your own risk.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.unsafe_reorder","page":"Manual","title":"BitBasis.unsafe_reorder","text":"unsafe_reorder(X::AbstractArray, orders)\n\nReorder X according to orders.\n\nwarning: Warning\nunsafe_reorder won't check whether the length of orders and the size of first dimension of X match, use at your own risk.\n\n\n\n\n\n","category":"function"},{"location":"man.html#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{N}, Tuple{UnitRange{T}, Tuple{Vararg{T, N}}}} where {N, T}","page":"Manual","title":"BitBasis.unsafe_sub","text":"unsafe_sub(a::UnitRange, b::NTuple{N}) -> NTuple{N}\n\nReturns result in type Tuple of a .- b. This will not check the length of a and b, use at your own risk.\n\n\n\n\n\n","category":"method"},{"location":"man.html#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{UnitRange{T}, Vector{T}}} where T","page":"Manual","title":"BitBasis.unsafe_sub","text":"unsafe_sub(a::UnitRange{T}, b::Vector{T}) where T\n\nReturns a .- b, fallback version when b is a Vector.\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using BitBasis, Dates\nend","category":"page"},{"location":"index.html#BitBasis","page":"Home","title":"BitBasis","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Manipulate binary (and nary) basis in an elegant efficient way in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Markdown, Dates\nMarkdown.parse(\"*Documentation built* **$(Dates.now())** *with Julia* **$(VERSION)**\")","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package provides tools for manipulating binary basis in an elegant efficient way in Julia. Binary basis are used to represent states of spins, qubits, qudits, etc. It stores the basis as an integer with little-endian ordering, e.g 5 for 00101, 6 for 00110, etc.","category":"page"},{"location":"index.html#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"man.md\",\n]","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"CurrentModule = BitBasis","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using BitBasis","category":"page"},{"location":"tutorial.html#Bit-strings","page":"Tutorial","title":"Bit strings","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"This package provides a string literal @bit_str to represent bit strings.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"b = bit\"11100\"\nBitStr{5}(0b11100)  # convert from integer\nbit_literal(0, 0, 1, 1, 1)  # from bit literals\n\n[b...]  # convert to a vector of bits\nb[2]  # indexing the 2nd bit\nb.buf  # the storage type is `Int64` by default\ntypeof(b)\nbit_length(b)  # the length of bit string","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The type of b is DitStr{2, 5, Int64}, which means it is a bit string with 5 bits and the storage type is Int64. The buf field is the integer representation of the bit string. Bit strings are represented as integers in the little-endian order, e.g. integer 28 represents the bit string 11100.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"<img src=\"assets/bitbasic.png\" alt=\"11100\" width=\"400\"/>","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The bit_literal function uses the array order to represent the bit string, which is different from the bit string literal, i.e. the leftmost bit is the least significant bit in the bit_literal function.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To represent bit strings with more than 64 bits, one can specify the storage type as Int128 or BigInt.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"b = bit_literal(rand(BigInt[0, 1], 200)...)\ntypeof(b)","category":"page"},{"location":"tutorial.html#Dit-Strings","page":"Tutorial","title":"Dit Strings","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"A nary basis is a generalization of a binary basis by changing the base from 2 to n. . A dit string is a nary basis with a given base. The @dit_str string literal is used to represent dit strings. For example, to represent a dit string with base 3, one can use the following code.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"d = dit\"12210;3\"\ntypeof(d)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The operations on dit strings are similar to those on bit strings.","category":"page"},{"location":"tutorial.html#Concatenation-and-Repetition","page":"Tutorial","title":"Concatenation and Repetition","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To concatenate and repeat bit strings, one can use join and repeat functions.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"join([bit\"101\" for i in 1:10]...)  # concatenate bit strings\nrepeat(bit\"101\", 2)  # repeat bit string","category":"page"},{"location":"tutorial.html#Readout","page":"Tutorial","title":"Readout","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To readout bits, one can use readbit and baddrs functions.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"<img src=\"assets/11100.png\" alt=\"11100\" width=\"400\"/>","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"readbit(bit\"11100\", 2, 3)  # read the 2nd and 3rd bits as `x₃x₂`\nbaddrs(bit\"11100\")  # locations of one bits","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"A bit string can be read out as numbers in the following ways:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"bint, the integer itself\nbint_r, the integer with bits small-big end reflected.\nbfloat, the float point number 0σ₁σ₂ cdots σ_n.\nbfloat_r, the float point number 0σ_n cdots σ₂σ₁.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"These functions are useful in quantum computing algorithms such as phase estimation and HHL.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"<img src = \"assets/010101.png\" alt=\"010101\" width=\"400\"/>","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"bint(bit\"010101\")\nbint_r(bit\"010101\")\nbfloat(bit\"010101\")\nbfloat_r(bit\"010101\")","category":"page"},{"location":"tutorial.html#Modification","page":"Tutorial","title":"Modification","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To flip all bits, one can use the neg function.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"neg(bit\"1011\")  # flip all bits","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To truncate bits, one can use the btruncate function.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"btruncate(bit\"1011\", 2)  # only keep the first 2 qubits","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To change the order of bits, one can use breflect function.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"<img src=\"assets/breflect.png\" alt=\"1011_1101\" width=\"200\"/>","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"breflect(bit\"1011\")  # reflect little end and big end","category":"page"},{"location":"tutorial.html#Masked-Operations","page":"Tutorial","title":"Masked Operations","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"One can use bmask to generate a mask for bit strings, and then use the mask to perform operations like allone, anyone, ismatch, flip, setbit, swapbits, etc.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"mask = bmask(BitStr{4, Int}, 1,3,4)  # mask bits 1, 3, 4","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"By coloring the masked positions in light blue, we have","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"<img src=\"assets/1011_1101.png\" alt=\"1011_1101\" width=\"400\"/>","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"allone(bit\"1011\", mask)  # true if all masked positions are 1\nanyone(bit\"1011\", mask)  # true if any masked positions is 1\nismatch(bit\"1011\", mask, bit\"1001\")  # true if masked part matches `1001`\nflip(bit\"1011\", mask)  # flip masked positions: 1, 3, 4\nsetbit(bit\"1011\", bit\"1100\") # set masked positions to 1\nswapbits(bit\"1011\", bit\"1100\")  # swap masked positions","category":"page"},{"location":"tutorial.html#Hamming-Distance","page":"Tutorial","title":"Hamming Distance","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"One can calculate the Hamming distance between two bit strings by bdistance function.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"bdistance(bit\"11100\", bit\"10101\")  # Hamming distance","category":"page"},{"location":"tutorial.html#Hilbert-Space","page":"Tutorial","title":"Hilbert Space","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The basis function is used to iterate over the basis of a given number of bits.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"itr = basis(BitStr{4, Int})\ncollect(itr)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Iterating over basis in a controlled way plays an important role in quantum simulation. The itercontrol function is used to iterate over basis in a controlled way. For example, if we want to iterate over the basis of 7 qubits, and we only want to iterate over the basis with the 1st, 3rd, 4th, and 7th qubits being 1, 0, 1, and 0, respectively, we can use the following code.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"for each in itercontrol(7, [1, 3, 4, 7], (1, 0, 1, 0))\n    println(string(each, base=2, pad=7))\nend","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"v = onehot(bit\"11100\")  # the one hot vector representation of given bits\nreorder(v, (3,2,1,5,4)) ≈ onehot(bit\"11001\")  # change the order of bits\ninvorder(v) ≈ onehot(bit\"00111\")  # change the order of bits","category":"page"},{"location":"tutorial.html#BitArray-Utilities","page":"Tutorial","title":"BitArray Utilities","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Utilities are provided to cast between integers and the BitArray type in Julia standard library.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"bitarray(integers, nbits), transform integers to BitArray.\npackabits(bitstring), transform BitArray to integers.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"barr = bitarray(28, 5)\npackbits(barr)\nbarr_mult = bitarray([4, 5, 6], 5)\npackbits(barr_mult)","category":"page"}]
}
