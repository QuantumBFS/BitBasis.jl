<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · BitBasis.jl</title><link rel="canonical" href="https://quantumbfs.github.io/BitBasis.jl/latest/tutorial/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><h1>BitBasis.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Conventions-1">Conventions</a></li><li><a class="toctext" href="#Integer-Representations-1">Integer Representations</a></li><li><a class="toctext" href="#bit_literal-1">Bit String Literal</a></li><li><a class="toctext" href="#Bit-Manipulations-1">Bit Manipulations</a></li><li><a class="toctext" href="#Number-Readouts-1">Number Readouts</a></li><li><a class="toctext" href="#Iterating-over-Bases-1">Iterating over Bases</a></li><li><a class="toctext" href="#Reordering-Basis-1">Reordering Basis</a></li></ul></li><li><a class="toctext" href="../man/">Manual</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/BitBasis.jl/blob/master/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h2><a class="nav-anchor" id="Conventions-1" href="#Conventions-1">Conventions</a></h2><p>We use <span>$σ$</span> to represent a binary digit, its subtitle usually refers to the position of a given binary digit inside a number (bit string).</p><p>There are two different representation orders of a bit string.</p><h3><a class="nav-anchor" id="array_order-1" href="#array_order-1"><strong>array order</strong></a></h3><p>This follows the order of <code>BitArray</code> or other array representation of bits, e.g</p><p>For number <code>0b011101</code> (<code>29</code>)</p><div>\[\sigma_1=1, \sigma_2=0, \sigma_3=1, \sigma_4=1, \sigma_5=1, \sigma_6=0\]</div><h3><a class="nav-anchor" id="literal_order-1" href="#literal_order-1"><strong>literal order</strong></a></h3><p>This follows the order of binary literal <code>0bxxxx</code>, e.g</p><p>For number <code>0b011101</code> (<code>29</code>)</p><div>\[\sigma_1=0, \sigma_2=1, \sigma_3=1, \sigma_4=1, \sigma_5=0, \sigma_6=1\]</div><h2><a class="nav-anchor" id="Integer-Representations-1" href="#Integer-Representations-1">Integer Representations</a></h2><p>We use an <code>Int</code> type to store bit-wise (spin) configurations, e.g. <code>0b011101</code> (<code>29</code>) represents the configuration</p><div>\[\sigma_1=1, \sigma_2=0, \sigma_3=1, \sigma_4=1, \sigma_5=1, \sigma_6=0\]</div><p>so we annotate the configurations <span>$\vec σ$</span> with integer <span>$b$</span> by <span>$b = \sum\limits_i 2^{i-1}σ_i$</span>. <img src="../assets/bitbasic.png" alt="11100"/> e.g. we can use a number <code>28</code> to represent bit configuration <code>0b11100</code></p><pre><code class="language-julia-repl">julia&gt; bdistance(0b11100, 0b10101) == 2  # Hamming distance
true

julia&gt; bit_length(0b11100) == 5
true</code></pre><p>In <code>BitBasis</code>, we also provide a more readable way to define these kind of objects, which is called <a href="#bit_literal-1">the bit string literal</a>, most of the integer operations and <code>BitBasis</code> functions are overloaded for <a href="#bit_literal-1">the bit string literal</a>.</p><p>We can switch between binary and digital representations with</p><ul><li><code>bitarray(integers, nbits)</code>, transform integers to bistrings of type <code>BitArray</code>.</li><li><code>packabits(bitstring)</code>, transform bitstrings to integers.</li><li><code>baddrs(integer)</code>, get the locations of nonzero qubits.</li></ul><pre><code class="language-julia-repl">julia&gt; bitarray(4, 5)
5-element BitArray{1}:
 false
 false
  true
 false
 false

julia&gt; bitarray([4, 5, 6], 5)
5×3 BitArray{2}:
 false   true  false
 false  false   true
  true   true   true
 false  false  false
 false  false  false

julia&gt; packbits([1, 1, 0])
3

julia&gt; bitarray([4, 5, 6], 5) |&gt; packbits;</code></pre><p>A curried version of the above function is also provided. See also <a href="../man/#BitBasis.bitarray-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T&lt;:Number"><code>bitarray</code></a>.</p><h2><a class="nav-anchor" id="bit_literal-1" href="#bit_literal-1">Bit String Literal</a></h2><p>bit strings are literals for bits, it provides better view on binary basis. you could use <a href="../man/#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a>, which looks like the following</p><pre><code class="language-julia-repl">julia&gt; bit&quot;101&quot; * 2
1010 (10)

julia&gt; bcat(bit&quot;101&quot; for i in 1:10)
101101101101101101101101101101 (766958445)

julia&gt; repeat(bit&quot;101&quot;, 2)
101101 (45)

julia&gt; bit&quot;1101&quot;[2]
0</code></pre><p>to define a bit string with length. <code>bit&quot;10101&quot;</code> is equivalent to <code>0b10101</code> on both performance and functionality but it store the length of given bits statically. The bit string literal offers a more readable syntax for these kind of objects.</p><p>Besides bit literal, you can convert a string or an integer to bit literal by <a href="../man/#BitBasis.bit-Tuple{Integer}"><code>bit</code></a>, e.g</p><pre><code class="language-julia-repl">julia&gt; bit(0b00101; len=5)
00101 (5)</code></pre><p>Or use the least number of digits required</p><pre><code class="language-julia-repl">julia&gt; bit(0b00101)
101 (5)</code></pre><h2><a class="nav-anchor" id="Bit-Manipulations-1" href="#Bit-Manipulations-1">Bit Manipulations</a></h2><h4><a class="nav-anchor" id="[readbit](@ref)-and-[baddrs](@ref)-1" href="#[readbit](@ref)-and-[baddrs](@ref)-1"><a href="../man/#BitBasis.readbit-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer"><code>readbit</code></a> and <a href="../man/#BitBasis.baddrs-Tuple{Integer}"><code>baddrs</code></a></a></h4><p><img src="../assets/11100.png" alt="11100"/></p><pre><code class="language-julia-repl">julia&gt; readbit(0b11100, 2, 3) == 0b10  # read the 2nd and 3rd bits as `x₃x₂`
true

julia&gt; baddrs(0b11100) == [3,4,5]  # locations of one bits
true</code></pre><h4><a class="nav-anchor" id="[bmask](@ref)-1" href="#[bmask](@ref)-1"><a href="../man/#BitBasis.bmask"><code>bmask</code></a></a></h4><p>Masking technic provides faster binary operations, to generate a mask with specific position masked, e.g. we want to mask qubits <code>1, 3, 4</code></p><pre><code class="language-julia-repl">julia&gt; mask = bmask(UInt8, 1,3,4)
0x0d

julia&gt; bit(mask; len=4)
1101 (13)</code></pre><h4><a class="nav-anchor" id="[allone](@ref)-and-[anyone](@ref)-1" href="#[allone](@ref)-and-[anyone](@ref)-1"><a href="../man/#BitBasis.allone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>allone</code></a> and <a href="../man/#BitBasis.anyone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>anyone</code></a></a></h4><p>with this mask (masked positions are colored light blue), we have <img src="../assets/1011_1101.png" alt="1011_1101"/></p><pre><code class="language-julia-repl">julia&gt; allone(0b1011, mask) == false # true if all masked positions are 1
true

julia&gt; anyone(0b1011, mask) == true # true if any masked positions is 1
true</code></pre><h4><a class="nav-anchor" id="[ismatch](@ref)-1" href="#[ismatch](@ref)-1"><a href="../man/#BitBasis.ismatch-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>ismatch</code></a></a></h4><p><img src="../assets/ismatch.png" alt="ismatch"/></p><pre><code class="language-julia-repl">julia&gt; ismatch(0b1011, mask, 0b1001) == true  # true if masked part matches `0b1001`
true</code></pre><h4><a class="nav-anchor" id="[flip](@ref)-1" href="#[flip](@ref)-1"><a href="../man/#BitBasis.flip-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>flip</code></a></a></h4><p><img src="../assets/flip.png" alt="1011_1101"/></p><pre><code class="language-julia-repl">julia&gt; bit(flip(0b1011, mask); len=4)  # flip masked positions
0110 (6)</code></pre><h4><a class="nav-anchor" id="[setbit](@ref)-1" href="#[setbit](@ref)-1"><a href="../man/#BitBasis.setbit-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>setbit</code></a></a></h4><p><img src="../assets/setbit.png" alt="setbit"/></p><pre><code class="language-julia-repl">julia&gt; setbit(0b1011, 0b1100) == 0b1111 # set masked positions 1
true</code></pre><h4><a class="nav-anchor" id="[swapbits](@ref)-1" href="#[swapbits](@ref)-1"><a href="../man/#BitBasis.swapbits-Union{Tuple{T}, Tuple{T,Int64,Int64}} where T&lt;:Integer"><code>swapbits</code></a></a></h4><p><img src="../assets/swapbits.png" alt="swapbits"/></p><pre><code class="language-julia-repl">julia&gt; swapbits(0b1011, 0b1100) == 0b0111  # swap masked positions
true</code></pre><h4><a class="nav-anchor" id="[neg](@ref)-1" href="#[neg](@ref)-1"><a href="../man/#BitBasis.neg-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer"><code>neg</code></a></a></h4><pre><code class="language-julia-repl">julia&gt; neg(0b1011, 2) == 0b1000
true</code></pre><h4><a class="nav-anchor" id="[btruncate](@ref)-and-[breflect](@ref)-1" href="#[btruncate](@ref)-and-[breflect](@ref)-1"><a href="../man/#BitBasis.btruncate-Tuple{Integer,Any}"><code>btruncate</code></a> and <a href="../man/#BitBasis.breflect"><code>breflect</code></a></a></h4><p><img src="../assets/btruncate.png" alt="btruncate"/></p><pre><code class="language-julia-repl">julia&gt; btruncate(0b1011, 2) == 0b0011  # only the first two qubits are retained
true</code></pre><h4><a class="nav-anchor" id="[breflect](@ref)-1" href="#[breflect](@ref)-1"><a href="../man/#BitBasis.breflect"><code>breflect</code></a></a></h4><p><img src="../assets/breflect.png" alt="breflect"/></p><pre><code class="language-julia-repl">julia&gt; breflect(4, 0b1011) == 0b1101  # reflect little end and big end
true</code></pre><p>For more detailed bitwise operations, see manual page <a href="../#BitBasis-1">BitBasis</a>.</p><h2><a class="nav-anchor" id="Number-Readouts-1" href="#Number-Readouts-1">Number Readouts</a></h2><p>In phase estimation and HHL algorithms, one need to read out qubits as integer or float point numbers. A register can be read out in different ways, like</p><ul><li><a href="@ref">bint</a>, the integer itself</li><li><a href="@ref">bint_r</a>, the integer with bits small-big end reflected.</li><li><a href="@ref">bfloat</a>, the float point number <span>$0.σ₁σ₂⋯σ\\_n$</span>.</li><li><a href="@ref">bfloat_r</a>, the float point number <span>$0.σ\\_n⋯σ₂σ₁$</span>.</li></ul><p><img src="../assets/010101.png" alt="010101"/></p><pre><code class="language-julia-repl">julia&gt; bint(0b010101)
0x15

julia&gt; bint_r(0b010101, nbits=6)
0x2a

julia&gt; bfloat(0b010101)
0.65625

julia&gt; bfloat_r(0b010101, nbits=6);</code></pre><p>Notice the functions with <code>_r</code> as postfix always require <code>nbits</code> as an additional input parameter to help reading, which is regarded as less natural way of expressing numbers.</p><h2><a class="nav-anchor" id="Iterating-over-Bases-1" href="#Iterating-over-Bases-1">Iterating over Bases</a></h2><p>Counting from <code>0</code> is very natural way of iterating quantum registers, very pity for <code>Julia</code></p><pre><code class="language-julia-repl">julia&gt; itr = basis(4)
0:15

julia&gt; collect(itr)
16-element Array{Int64,1}:
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15</code></pre><p><a href="../man/#BitBasis.itercontrol-Tuple{Int64,AbstractArray{T,1} where T,Any}"><code>itercontrol</code></a> is a complicated API, but it plays an fundamental role in high performance quantum simulation of <code>Yao</code>. It is used for iterating over basis in controlled way, its interface looks like</p><pre><code class="language-julia-repl">julia&gt; for each in itercontrol(7, [1, 3, 4, 7], (1, 0, 1, 0))
           println(string(each, base=2, pad=7))
       end
0001001
0001011
0011001
0011011
0101001
0101011
0111001
0111011</code></pre><h2><a class="nav-anchor" id="Reordering-Basis-1" href="#Reordering-Basis-1">Reordering Basis</a></h2><p>We store the wave function as <span>$v[b+1] := \langle b|\psi\rangle$</span>. We are able to reorder the basis as</p><pre><code class="language-julia-repl">julia&gt; v = onehot(5, 0b11100)  # the one hot vector representation of given bits
32-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0
 0.0

julia&gt; reorder(v, (3,2,1,5,4)) ≈ onehot(5, 0b11001)
true

julia&gt; invorder(v) ≈ onehot(5, 0b00111)  # breflect for each basis
true</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../man/"><span class="direction">Next</span><span class="title">Manual</span></a></footer></article></body></html>
