<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · BitBasis.jl</title><link rel="canonical" href="https://quantumbfs.github.io/BitBasis.jl/latest/tutorial/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="BitBasis.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">BitBasis.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Conventions-1"><span>Conventions</span></a></li><li><a class="tocitem" href="#Integer-Representations-1"><span>Integer Representations</span></a></li><li><a class="tocitem" href="#bit_literal-1"><span>Bit String Literal</span></a></li><li><a class="tocitem" href="#Bit-Manipulations-1"><span>Bit Manipulations</span></a></li><li><a class="tocitem" href="#Number-Readouts-1"><span>Number Readouts</span></a></li><li><a class="tocitem" href="#Iterating-over-Bases-1"><span>Iterating over Bases</span></a></li><li><a class="tocitem" href="#Reordering-Basis-1"><span>Reordering Basis</span></a></li></ul></li><li><a class="tocitem" href="../man/">Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/BitBasis.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Conventions-1"><a class="docs-heading-anchor" href="#Conventions-1">Conventions</a><a class="docs-heading-anchor-permalink" href="#Conventions-1" title="Permalink"></a></h2><p>We use <span>$σ$</span> to represent a binary digit, its subtitle usually refers to the position of a given binary digit inside a number (bit string).</p><p>In computing, bit numbering (or sometimes bit endianness) is the convention used to identify the bit positions in a binary number or a container of such a value. The bit number starts with zero and is incremented by one for each subsequent bit position. See also <a href="https://en.wikipedia.org/wiki/Bit_numbering">Bit numbering</a>(<strong>(Bit endianness)</strong>).</p><p>There are two different representation orders of a bit string:</p><ul><li><strong>Least significant bit 0 bit  numbering</strong></li><li><strong>Most significant bit 0 bit numbering</strong></li></ul><h3 id="array_order-1"><a class="docs-heading-anchor" href="#array_order-1"><strong>LSB 0 bit numbering</strong></a><a class="docs-heading-anchor-permalink" href="#array_order-1" title="Permalink"></a></h3><p>This follows the order of <code>BitArray</code> or other array representation of bits, e.g</p><p>For number <code>0b011101</code> (<code>29</code>)</p><div>\[\sigma_1=1, \sigma_2=0, \sigma_3=1, \sigma_4=1, \sigma_5=1, \sigma_6=0\]</div><p>See also <a href="https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering">LSB 0 bit numbering</a></p><h3 id="literal_order-1"><a class="docs-heading-anchor" href="#literal_order-1"><strong>MSB 0 bit numbering</strong></a><a class="docs-heading-anchor-permalink" href="#literal_order-1" title="Permalink"></a></h3><p>This follows the order of binary literal <code>0bxxxx</code>, e.g</p><p>For number <code>0b011101</code> (<code>29</code>)</p><div>\[\sigma_1=0, \sigma_2=1, \sigma_3=1, \sigma_4=1, \sigma_5=0, \sigma_6=1\]</div><p>See also <a href="https://en.wikipedia.org/wiki/Bit_numbering#MSB_0_bit_numbering">MSB 0 bit numbering</a>.</p><h2 id="Integer-Representations-1"><a class="docs-heading-anchor" href="#Integer-Representations-1">Integer Representations</a><a class="docs-heading-anchor-permalink" href="#Integer-Representations-1" title="Permalink"></a></h2><p>We use an <code>Int</code> type to store bit-wise (spin) configurations, e.g. <code>0b011101</code> (<code>29</code>) represents the configuration</p><div>\[\sigma_1=1, \sigma_2=0, \sigma_3=1, \sigma_4=1, \sigma_5=1, \sigma_6=0\]</div><p>so we annotate the configurations <span>$\vec σ$</span> with integer <span>$b$</span> by <span>$b = \sum\limits_i 2^{i-1}σ_i$</span>. <img src="../assets/bitbasic.png" alt="11100"/> e.g. we can use a number <code>28</code> to represent bit configuration <code>0b11100</code></p><pre><code class="language-julia-repl">julia&gt; bdistance(0b11100, 0b10101) == 2  # Hamming distance
true

julia&gt; bit_length(0b11100) == 5
true</code></pre><p>In <code>BitBasis</code>, we also provide a more readable way to define these kind of objects, which is called <a href="#bit_literal-1">the bit string literal</a>, most of the integer operations and <code>BitBasis</code> functions are overloaded for <a href="#bit_literal-1">the bit string literal</a>.</p><p>We can switch between binary and digital representations with</p><ul><li><code>bitarray(integers, nbits)</code>, transform integers to bistrings of type <code>BitArray</code>.</li><li><code>packabits(bitstring)</code>, transform bitstrings to integers.</li><li><code>baddrs(integer)</code>, get the locations of nonzero qubits.</li></ul><pre><code class="language-julia-repl">julia&gt; bitarray(4, 5)
5-element BitArray{1}:
 false
 false
  true
 false
 false

julia&gt; bitarray([4, 5, 6], 5)
5×3 BitArray{2}:
 false   true  false
 false  false   true
  true   true   true
 false  false  false
 false  false  false

julia&gt; packbits([1, 1, 0])
3

julia&gt; bitarray([4, 5, 6], 5) |&gt; packbits;</code></pre><p>A curried version of the above function is also provided. See also <a href="../man/#BitBasis.bitarray-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T&lt;:Number"><code>bitarray</code></a>.</p><h2 id="bit_literal-1"><a class="docs-heading-anchor" href="#bit_literal-1">Bit String Literal</a><a class="docs-heading-anchor-permalink" href="#bit_literal-1" title="Permalink"></a></h2><p>bit strings are literals for bits, it provides better view on binary basis. you could use <a href="../man/#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a>, which looks like the following</p><pre><code class="language-julia-repl">julia&gt; bit&quot;101&quot; * 2
1010 ₍₂₎

julia&gt; bcat(bit&quot;101&quot; for i in 1:10)
101101101101101101101101101101 ₍₂₎

julia&gt; repeat(bit&quot;101&quot;, 2)
101101 ₍₂₎

julia&gt; bit&quot;1101&quot;[2]
0</code></pre><p>to define a bit string with length. <code>bit&quot;10101&quot;</code> is equivalent to <code>0b10101</code> on both performance and functionality but it store the length of given bits statically. The bit string literal offers a more readable syntax for these kind of objects.</p><p>Besides bit literal, you can convert a string or an integer to bit literal by <a href="@ref"><code>bit</code></a>, e.g</p><pre><code class="language-julia-repl">julia&gt; BitStr{5}(0b00101)
ERROR: MethodError: no method matching BitStr{5,T} where T(::UInt8)
Closest candidates are:
  BitStr{5,T} where T(::T&lt;:Number) where T&lt;:Number at boot.jl:741
  BitStr{5,T} where T(!Matched::Float16) where T&lt;:Integer at float.jl:71
  BitStr{5,T} where T(!Matched::Complex) where T&lt;:Real at complex.jl:37
  ...</code></pre><h2 id="Bit-Manipulations-1"><a class="docs-heading-anchor" href="#Bit-Manipulations-1">Bit Manipulations</a><a class="docs-heading-anchor-permalink" href="#Bit-Manipulations-1" title="Permalink"></a></h2><h4 id="[readbit](@ref)-and-[baddrs](@ref)-1"><a class="docs-heading-anchor" href="#[readbit](@ref)-and-[baddrs](@ref)-1"><a href="../man/#BitBasis.readbit-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer"><code>readbit</code></a> and <a href="../man/#BitBasis.baddrs-Tuple{Integer}"><code>baddrs</code></a></a><a class="docs-heading-anchor-permalink" href="#[readbit](@ref)-and-[baddrs](@ref)-1" title="Permalink"></a></h4><p><img src="../assets/11100.png" alt="11100"/></p><pre><code class="language-julia-repl">julia&gt; readbit(0b11100, 2, 3) == 0b10  # read the 2nd and 3rd bits as `x₃x₂`
true

julia&gt; baddrs(0b11100) == [3,4,5]  # locations of one bits
true</code></pre><h4 id="[bmask](@ref)-1"><a class="docs-heading-anchor" href="#[bmask](@ref)-1"><a href="../man/#BitBasis.bmask"><code>bmask</code></a></a><a class="docs-heading-anchor-permalink" href="#[bmask](@ref)-1" title="Permalink"></a></h4><p>Masking technic provides faster binary operations, to generate a mask with specific position masked, e.g. we want to mask qubits <code>1, 3, 4</code></p><pre><code class="language-julia-repl">julia&gt; mask = bmask(UInt8, 1,3,4)
0x0d

julia&gt; bit(mask; len=4)
┌ Warning: `bit(b; len)` is deprecated, use `BitStr{len}(b)` instead.
│   caller = ip:0x0
└ @ Core :-1
ERROR: MethodError: no method matching BitStr{4,T} where T(::UInt8)
Closest candidates are:
  BitStr{4,T} where T(::T&lt;:Number) where T&lt;:Number at boot.jl:741
  BitStr{4,T} where T(!Matched::Float16) where T&lt;:Integer at float.jl:71
  BitStr{4,T} where T(!Matched::Complex) where T&lt;:Real at complex.jl:37
  ...</code></pre><h4 id="[allone](@ref)-and-[anyone](@ref)-1"><a class="docs-heading-anchor" href="#[allone](@ref)-and-[anyone](@ref)-1"><a href="../man/#BitBasis.allone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>allone</code></a> and <a href="../man/#BitBasis.anyone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>anyone</code></a></a><a class="docs-heading-anchor-permalink" href="#[allone](@ref)-and-[anyone](@ref)-1" title="Permalink"></a></h4><p>with this mask (masked positions are colored light blue), we have <img src="../assets/1011_1101.png" alt="1011_1101"/></p><pre><code class="language-julia-repl">julia&gt; allone(0b1011, mask) == false # true if all masked positions are 1
true

julia&gt; anyone(0b1011, mask) == true # true if any masked positions is 1
true</code></pre><h4 id="[ismatch](@ref)-1"><a class="docs-heading-anchor" href="#[ismatch](@ref)-1"><a href="../man/#BitBasis.ismatch-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>ismatch</code></a></a><a class="docs-heading-anchor-permalink" href="#[ismatch](@ref)-1" title="Permalink"></a></h4><p><img src="../assets/ismatch.png" alt="ismatch"/></p><pre><code class="language-julia-repl">julia&gt; ismatch(0b1011, mask, 0b1001) == true  # true if masked part matches `0b1001`
true</code></pre><h4 id="[flip](@ref)-1"><a class="docs-heading-anchor" href="#[flip](@ref)-1"><a href="../man/#BitBasis.flip-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>flip</code></a></a><a class="docs-heading-anchor-permalink" href="#[flip](@ref)-1" title="Permalink"></a></h4><p><img src="../assets/flip.png" alt="1011_1101"/></p><pre><code class="language-julia-repl">julia&gt; bit(flip(0b1011, mask); len=4)  # flip masked positions
┌ Warning: `bit(b; len)` is deprecated, use `BitStr{len}(b)` instead.
│   caller = ip:0x0
└ @ Core :-1
ERROR: MethodError: no method matching BitStr{4,T} where T(::UInt8)
Closest candidates are:
  BitStr{4,T} where T(::T&lt;:Number) where T&lt;:Number at boot.jl:741
  BitStr{4,T} where T(!Matched::Float16) where T&lt;:Integer at float.jl:71
  BitStr{4,T} where T(!Matched::Complex) where T&lt;:Real at complex.jl:37
  ...</code></pre><h4 id="[setbit](@ref)-1"><a class="docs-heading-anchor" href="#[setbit](@ref)-1"><a href="../man/#BitBasis.setbit-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>setbit</code></a></a><a class="docs-heading-anchor-permalink" href="#[setbit](@ref)-1" title="Permalink"></a></h4><p><img src="../assets/setbit.png" alt="setbit"/></p><pre><code class="language-julia-repl">julia&gt; setbit(0b1011, 0b1100) == 0b1111 # set masked positions 1
true</code></pre><h4 id="[swapbits](@ref)-1"><a class="docs-heading-anchor" href="#[swapbits](@ref)-1"><a href="../man/#BitBasis.swapbits-Union{Tuple{T}, Tuple{T,Int64,Int64}} where T&lt;:Integer"><code>swapbits</code></a></a><a class="docs-heading-anchor-permalink" href="#[swapbits](@ref)-1" title="Permalink"></a></h4><p><img src="../assets/swapbits.png" alt="swapbits"/></p><pre><code class="language-julia-repl">julia&gt; swapbits(0b1011, 0b1100) == 0b0111  # swap masked positions
true</code></pre><h4 id="[neg](@ref)-1"><a class="docs-heading-anchor" href="#[neg](@ref)-1"><a href="../man/#BitBasis.neg-Union{Tuple{BitStr{N,T} where T}, Tuple{N}} where N"><code>neg</code></a></a><a class="docs-heading-anchor-permalink" href="#[neg](@ref)-1" title="Permalink"></a></h4><pre><code class="language-julia-repl">julia&gt; neg(0b1011, 2) == 0b1000
true</code></pre><h4 id="[btruncate](@ref)-and-[breflect](@ref)-1"><a class="docs-heading-anchor" href="#[btruncate](@ref)-and-[breflect](@ref)-1"><a href="../man/#BitBasis.btruncate-Tuple{Integer,Any}"><code>btruncate</code></a> and <a href="../man/#BitBasis.breflect"><code>breflect</code></a></a><a class="docs-heading-anchor-permalink" href="#[btruncate](@ref)-and-[breflect](@ref)-1" title="Permalink"></a></h4><p><img src="../assets/btruncate.png" alt="btruncate"/></p><pre><code class="language-julia-repl">julia&gt; btruncate(0b1011, 2) == 0b0011  # only the first two qubits are retained
true</code></pre><h4 id="[breflect](@ref)-1"><a class="docs-heading-anchor" href="#[breflect](@ref)-1"><a href="../man/#BitBasis.breflect"><code>breflect</code></a></a><a class="docs-heading-anchor-permalink" href="#[breflect](@ref)-1" title="Permalink"></a></h4><p><img src="../assets/breflect.png" alt="breflect"/></p><pre><code class="language-julia-repl">julia&gt; breflect(4, 0b1011) == 0b1101  # reflect little end and big end
┌ Warning: `breflect(nbits::Int, b::Integer)` is deprecated, use `breflect(b; nbits=nbits)` instead.
│   caller = top-level scope at none:0
└ @ Core none:0
true</code></pre><p>For more detailed bitwise operations, see manual page <a href="../#BitBasis-1">BitBasis</a>.</p><h2 id="Number-Readouts-1"><a class="docs-heading-anchor" href="#Number-Readouts-1">Number Readouts</a><a class="docs-heading-anchor-permalink" href="#Number-Readouts-1" title="Permalink"></a></h2><p>In phase estimation and HHL algorithms, one need to read out qubits as integer or float point numbers. A register can be read out in different ways, like</p><ul><li><a href="../man/#BitBasis.bint-Tuple{BitStr}"><code>bint</code></a>, the integer itself</li><li><a href="../man/#BitBasis.bint_r-Tuple{Integer}"><code>bint_r</code></a>, the integer with bits small-big end reflected.</li><li><a href="../man/#BitBasis.bfloat-Tuple{Integer}"><code>bfloat</code></a>, the float point number <span>$0.σ₁σ₂ \cdots σ_n$</span>.</li><li><a href="../man/#BitBasis.bfloat_r-Tuple{Integer}"><code>bfloat_r</code></a>, the float point number <span>$0.σ_n \cdots σ₂σ₁$</span>.</li></ul><p><img src="../assets/010101.png" alt="010101"/></p><pre><code class="language-julia-repl">julia&gt; bint(0b010101)
0x15

julia&gt; bint_r(0b010101, nbits=6)
0x2a

julia&gt; bfloat(0b010101)
0.65625

julia&gt; bfloat_r(0b010101, nbits=6);</code></pre><p>Notice the functions with <code>_r</code> as postfix always require <code>nbits</code> as an additional input parameter to help reading, which is regarded as less natural way of expressing numbers.</p><h2 id="Iterating-over-Bases-1"><a class="docs-heading-anchor" href="#Iterating-over-Bases-1">Iterating over Bases</a><a class="docs-heading-anchor-permalink" href="#Iterating-over-Bases-1" title="Permalink"></a></h2><p>Counting from <code>0</code> is very natural way of iterating quantum registers, very pity for <code>Julia</code></p><pre><code class="language-julia-repl">julia&gt; itr = basis(4)
0:15

julia&gt; collect(itr)
16-element Array{Int64,1}:
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15</code></pre><p><a href="@ref"><code>itercontrol</code></a> is a complicated API, but it plays an fundamental role in high performance quantum simulation of <code>Yao</code>. It is used for iterating over basis in controlled way, its interface looks like</p><pre><code class="language-julia-repl">julia&gt; for each in itercontrol(7, [1, 3, 4, 7], (1, 0, 1, 0))
           println(string(each, base=2, pad=7))
       end
0001001
0001011
0011001
0011011
0101001
0101011
0111001
0111011</code></pre><h2 id="Reordering-Basis-1"><a class="docs-heading-anchor" href="#Reordering-Basis-1">Reordering Basis</a><a class="docs-heading-anchor-permalink" href="#Reordering-Basis-1" title="Permalink"></a></h2><p>We store the wave function as <span>$v[b+1] := \langle b|\psi\rangle$</span>. We are able to reorder the basis as</p><pre><code class="language-julia-repl">julia&gt; v = onehot(5, 0b11100)  # the one hot vector representation of given bits
32-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0
 0.0

julia&gt; reorder(v, (3,2,1,5,4)) ≈ onehot(5, 0b11001)
true

julia&gt; invorder(v) ≈ onehot(5, 0b00111)  # breflect for each basis
true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../man/">Manual »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 8 December 2019 07:58">Sunday 8 December 2019</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
